# Structural design patterns
Структурные шаблоны проектирования полностью посвящены композиции классов и объектов. Структурные шаблоны создания классов используют наследование для создания интерфейсов. Структурные шаблоны объектов определяют способы составления объектов для получения новой функциональности.

В программной инженерии шаблоны структурного проектирования — это шаблоны проектирования, которые упрощают проектирование, определяя простой способ реализации связей между сущностями.


## Adapter
Сопосталяет интерфейсы разных классов

#### Real life analogies:
![adapter_HA.png](images%2Fadapter_HA.png)
![adapter2_HA.png](images%2Fadapter2_HA.png)

## Bridge
Отделяет интерфейс объекта от его реализации.

#### Real life analogies:
![bridge_HA.png](images%2Fbridge_HA.png)

## Composite
Древовидная структура простых и составных объектов.

#### Real life analogies:
![composite_HA.png](images%2Fcomposite_HA.png)

## Decorator
Динамическое добавление обязанностей к объектам

#### Real life analogies:
![decorator_HA.png](images%2Fdecorator_HA.png)

## Facade
Один класс, представляющий всю подсистему.

#### Real life analogies:
![facade_HA.png](images%2Ffacade_HA.png)

## Flyweight
Детализированный экземпляр, используемый для эффективного совместного использования

#### Real life analogies:
![flyweight_HA.png](images%2Fflyweight_HA.png)

## Private Class Data
TODO..

## Proxy
Объект, представляющий другой объект

#### Real life analogies:
![proxy_HA.png](images%2Fproxy_HA.png)


# Эмпирические правила

1. <b>Адаптер</b> заставляет вещи работать после того, как они были спроектированы; <b>Бридж</b> заставляет их работать раньше, чем они есть.
2. <b>Bridge</b> спроектирован заранее, чтобы позволить абстракции и реализации изменяться независимо. <b>Адаптер</b> модернизирован, чтобы обеспечить совместную работу несвязанных классов.
3. <b>Адаптер</b> предоставляет другой интерфейс для своего объекта. <b>Прокси</b> предоставляет тот же интерфейс. <b>Декоратор</b> предоставляет улучшенный интерфейс.
4. <b>Адаптер</b> меняет интерфейс объекта, <b>Декоратор</b> расширяет возможности объекта. Таким образом, <b>Decorator</b> становится более прозрачным для клиента. Как следствие, <b>Decorator</b> поддерживает рекурсивную композицию, что невозможно при использовании чистых <b>адаптеров</b>.
5. <b>Composite</b> и <b>Decorator</b> имеют схожие структурные диаграммы, что отражает тот факт, что оба используют рекурсивную композицию для организации неограниченного количества объектов.
6. <b>Композит</b> можно пройти с помощью <b>Iterator</b>. <b>Посетитель</b> может применить операцию к <b>Composite</b>. <b>Composite</b> может использовать <b>цепочку ответственности</b>, чтобы позволить компонентам получать доступ к глобальным свойствам через своего родителя. <b>Composite</b> также может использовать <b>Decorator</b> для переопределения этих свойств частей композиции. Он мог бы использовать <b>Observer</b> для привязки одной структуры объекта к другой и <b>State</b>, чтобы позволить компоненту изменять свое поведение при изменении его состояния.
7. <b>Composite</b> позволяет вам составить <b>Mediator</b> из более мелких частей посредством рекурсивной композиции.
8. <b>Декоратор</b> позволяет изменить внешний вид объекта. <b>Стратегия</b> позволяет вам изменить внутренности.
9. <b>Декоратор</b> предназначен для того, чтобы вы могли добавлять обязанности к объектам без создания подклассов. Основное внимание <b>Composite</b> уделяется не украшению, а репрезентации. Эти намерения различны, но дополняют друг друга. Следовательно, <b>Composite</b> и <b>Decorator</b> часто используются совместно.
10. <b>Декоратор</b> и <b>Прокси</b> имеют разные цели, но схожую структуру. Оба описывают, как обеспечить уровень косвенности к другому объекту, и реализации сохраняют ссылку на объект, которому они перенаправляют запросы.
11. <b>Фасад</b> определяет новый интерфейс, тогда как <b>Адаптер</b> повторно использует старый интерфейс. Помните, что <b>Aдаптер</b> обеспечивает совместную работу двух существующих интерфейсов, а не определяет совершенно новый.
12. <b>Фасадные</b> объекты часто являются одноэлементными, поскольку требуется только один фасадный объект.
13. <b>Mediator</b> похож на <b>Facade</b> в том, что он абстрагирует функциональность существующих классов. <b>Mediator</b> абстрагирует/централизует произвольную связь между объектами-коллегами, он обычно «добавляет ценность» и известен/на него ссылаются объекты-коллеги. А <b>Facade</b> определяет более простой интерфейс для подсистемы, не добавляет новых функций и неизвестен классам подсистемы.
14. <b>Abstract Factory</b> можно использовать в качестве альтернативы <b>Facade</b> для сокрытия классов, специфичных для платформы.
15. В то время как <b>Flyweight</b> показывает, как создавать множество маленьких объектов, <b>Facade</b> показывает, как сделать так, чтобы один объект представлял целую подсистему.
16. <b>Flyweight</b> часто комбинируется с <b>Composite</b> для реализации общих конечных узлов.
17. <b>Flyweight</b> объясняет, когда и как можно совместно использовать объекты <b>State</b>.