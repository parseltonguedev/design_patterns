# Behavioral design patterns


## Chain of responsibility
Способ передачи запроса между цепочкой объектов

#### Real life analogies:
![chain-of-responsibility_HA.png](images%2Fchain-of-responsibility_HA.png)
## Command
Инкапсулировать запрос команды как объект

#### Real life analogies:
![command_HA.png](images%2Fcommand_HA.png)
## Interpreter
Способ включения языковых элементов в программу

#### Real life analogies:
![interpreter_HA.png](images%2Finterpreter_HA.png)
## Iterator
Последовательный доступ к элементам коллекции

#### Real life analogies:
![iterator_HA.png](images%2Fiterator_HA.png)
## Mediator
Определяет упрощенную связь между классами

#### Real life analogies:
![mediator_HA.png](images%2Fmediator_HA.png)
## Memento
Захват и восстановление внутреннего состояния объекта

#### Real life analogies:
![memento_HA.png](images%2Fmemento_HA.png)

## Null Object
TODO

## Observer
Способ уведомления об изменении ряда классов

#### Real life analogies:
![observer_HA.png](images%2Fobserver_HA.png)
## State
Изменить поведение объекта при изменении его состояния

#### Real life analogies:
![state_HA.png](images%2Fstate_HA.png)
## Strategy
Инкапсулирует алгоритм внутри класса

#### Real life analogies:
![strategy_HA.png](images%2Fstrategy_HA.png)
## Template Method
Перенесите точные шаги алгоритма в подкласс

#### Real life analogies:
![template_method_HA.png](images%2Ftemplate_method_HA.png)
## Visitor
Определяет новую операцию для класса без изменений

#### Real life analogies:
![visitor_HA.png](images%2Fvisitor_HA.png)

# Эмпирические правила

1. Поведенческие шаблоны связаны с распределением обязанностей между объектами или инкапсуляцией поведения в объекте и делегированием ему запросов.
2. **Цепочка ответственности**, **Команда**, **«Посредник»** и **«Наблюдатель»** описывает, как можно разделить отправителей и получателей, но с разными компромиссами. **Цепочка ответственности** передает запрос отправителя по цепочке потенциальных получателей. **Команда** обычно определяет соединение отправителя-получателя с подклассом. В **посреднике** отправители и получатели косвенно ссылаются друг на друга. **Observer** определяет очень развязанный интерфейс, который позволяет настраивать несколько приемников во время выполнения.
3. **Цепочка ответственности** может использовать **Команду** для представления запросов в виде объектов.
4. **Цепочка ответственности** часто применяется в сочетании с **Composite**. Здесь родительский элемент компонента может выступать в качестве его преемника.
5. **Command** и **Memento** действуют как магические токены, которые можно передавать и вызывать позже. В **Command** токен представляет запрос; в **Memento** он представляет внутреннее состояние объекта в определенный момент времени. Полиморфизм важен для **Command**, но не для **Memento**, поскольку его интерфейс настолько узок, что **Memento** можно передать только как значение.
6. **Команда** может использовать **Memento** для поддержания состояния, необходимого для операции отмены.
7. Макро**Команды** могут быть реализованы с помощью **Composite**.
8. **Команда**, которую необходимо скопировать перед помещением в список истории, действует как **прототип**.
9. **Интерпретатор** может использовать **State** для определения контекстов синтаксического анализа.
10. Абстрактное синтаксическое дерево **Интерпретатора** является **Composite** (поэтому также применимы **Итератор** и **Посетитель**).
11. Терминальные символы в абстрактном синтаксическом дереве **Interpreter** могут использоваться совместно с **Flyweight**.
12. **Итератор** может проходить по **Composite**. **Посетитель** может применить операцию к **Composite**.
13. Полиморфные **итераторы** полагаются на **фабричные методы** для создания экземпляра соответствующего подкласса **Iterator**.
14. **Посредник** и **Наблюдатель** — это конкурирующие модели. Разница между ними заключается в том, что **Observer** распределяет связь, вводя объекты «**наблюдатель**» и «субъект», тогда как объект **Mediator** инкапсулирует связь между другими объектами. Мы обнаружили, что создавать многоразовых **Наблюдателей** и Субъектов проще, чем многоразовых **Посредников**.
15. С другой стороны, **Mediator** может использовать **Observer** для динамической регистрации коллег и общения с ними.
16. **Mediator** похож на **Facade** в том, что он абстрагирует функциональность существующих классов. **Посредник** абстрагирует/централизует произвольную связь между объектами-коллегами, он обычно «добавляет ценность» и известен/на него ссылаются объекты-коллеги (т. е. он определяет многонаправленный протокол). А, **Facade** определяет более простой интерфейс для подсистемы, не добавляет новых функций и неизвестен классам подсистемы (т. е. определяет однонаправленный протокол, по которому он выполняет запросы к классам подсистемы, но не наоборот).
17. **Memento** часто используется вместе с **Iterator**. **Итератор** может использовать **Memento** для фиксации состояния итерации. **Итератор** хранит **Memento** внутри себя.
18. **State** похоже на Стратегию, за исключением своего намерения.
19. **Flyweight** объясняет, когда и как можно совместно использовать объекты **State**.
20. Объекты **State** часто являются **Cинглтонами**.
21. **Стратегия** позволяет вам изменить внутренности объекта. **Декоратор** позволяет менять обертку.
22. **Strategy** is to algorithm. as **Builder** is to creation.
23. **Стратегия** имеет две разные реализации, первая похожа на **State**. Разница заключается во времени привязки (**Strategy** — это шаблон с однократной привязкой, тогда как **State** более динамичен).
24. Объекты **стратегии** часто становятся хорошими **легковесами**.
25. **Стратегия** похожа на **метод шаблона**, за исключением своей детализации.
26. **Метод шаблона** использует наследование для изменения части алгоритма. **Стратегия** использует делегирование для изменения всего алгоритма.
27. Шаблон **«Посетитель»** похож на более мощный шаблон **«Команда»**, поскольку **посетитель** может инициировать все, что подходит для типа объекта, с которым он сталкивается.