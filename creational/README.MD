# Creational design patterns

Порождающие шаблоны проектирования связаны с созданием экземпляров классов. Этот шаблон можно далее разделить на шаблоны создания классов и шаблоны создания объектов. В то время как шаблоны создания классов эффективно используют наследование в процессе создания экземпляров, шаблоны создания объектов эффективно используют делегирование для выполнения работы.

Порождающие шаблоны проектирования связаны с механизмами создания объектов и пытаются создавать объекты способом, подходящим для конкретной ситуации. Базовая форма создания объекта может привести к проблемам с проектированием или усложнить проект. Порождающие шаблоны решают эту проблему, каким-то образом управляя созданием объекта.


## Abstract Factory

Создает экземпляр нескольких семейств классов.

#### Real life analogies:
![abstractfactory_HA.png](images%2Fabstractfactory_HA.png)

## Builder
Отделяет конструкцию объекта от его представления.
#### Real life analogies:
![builder_HA.png](images%2Fbuilder_HA.png)

## Factory Method
Создает экземпляр нескольких производных классов
#### Real life analogies:
![factory_method_HA.png](images%2Ffactory_method_HA.png)

## Object Pool
TODO

## Prototype
Полностью инициализированный экземпляр для копирования или клонирования.
#### Real life analogies:
![prototype_HA.png](images%2Fprototype_HA.png)

## Singleton
Класс, у которого может существовать только один экземпляр.
#### Real life analogies:
![singleton_HA.png](images%2Fsingleton_HA.png)


# Эмпирические правила

1. Иногда порождающие шаблоны являются конкурентами: бывают случаи, когда можно с выгодой использовать либо **Prototype**, либо **Abstract Factory**. В других случаях они дополняют друг друга: **Abstract Factory** может хранить набор **прототипов**, из которых можно клонировать и возвращать объекты продукта, **Builder** может использовать один из других шаблонов для реализации того, какие компоненты собираются. **Abstract Factory**, **Builder** и **Prototype** могут использовать **Singleton** в своей реализации.
2. **Abstract Factory**, **Builder** и **Prototype** определяют объект фабрики, который отвечает за знание и создание класса объектов продукта, и делают его параметром системы. **Abstract Factory** имеет объект-фабрику, производящую объекты нескольких классов. В **Builder** есть объект-фабрика, постепенно создающий сложный продукт с использованием соответственно сложного протокола. В **прототипе** есть объект-фабрика (он же прототип), создающий продукт путем копирования объекта-прототипа.
3. **Абстрактные фабричные** классы часто реализуются с помощью **фабричных методов**, но их также можно реализовать с помощью **прототипа**.
4. **Abstract Factory** можно использовать в качестве альтернативы **Facade** для сокрытия классов, специфичных для платформы.
5. **Builder** фокусируется на построении сложного объекта шаг за шагом. **Абстрактная фабрика** выделяет семейство объектов-продуктов (простых или сложных). **Builder** возвращает продукт на последнем этапе, но что касается **Абстрактной фабрики**, продукт возвращается немедленно.
6. **Строитель** относится к созданию так же, как **Стратегия** относится к алгоритму.
7. **Builder** часто строит **Composite**.
8. **Фабричные методы** обычно вызываются внутри **методов шаблона**.
9. **Фабричный метод**: создание через наследование. **Прототип**: создание через делегирование.
10. Часто проекты начинаются с использования **фабричного метода** (менее сложного, более настраиваемого, подклассы размножаются) и развиваются в сторону **абстрактной фабрики**, **прототипа** или **конструктора** (более гибкого, более сложного) по мере обноружения, где требуется большая гибкость.
11. **Прототип** не требует создания подклассов, но требует операции инициализации. **Фабричный метод** требует создания подклассов, но не требует инициализации.
12. Проекты, в которых интенсивно используются шаблоны **Composite** и **Decorator**, часто также могут извлечь выгоду из **Prototype**.